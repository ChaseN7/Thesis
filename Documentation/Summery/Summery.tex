\documentclass{article}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{german}
\usepackage{color}
\usepackage{bbm}
\usepackage[utf8]{inputenc}
\title{Small summery}
\author{Boris Prochnau}
\begin{document}
\maketitle
\tableofcontents
\section{First meeting (14.04): Model of interest}
These are some main points of the model we are using for the simulation. They are the product of the first meeting with Loren Coquille and Martina Baar.
\begin{itemize}
	\item We have N traints and ($X_{i=1,...,N}$) are the amount of members of the traits. 
	\item We use a constant mutation rate that does not depend on the traits $\mu$.
	\item but the other rates are depending on traits and change with time (by as the amount of traitmembers rises)
		\begin{itemize}
			\item $b_i$, [intrinsic birth-rate]
			\item $d_i$, [intrinsic death-rate]
			\item $\left(\sum_{j=1}^N \frac{c_{\cdot,j}}{K}x_j\right)_i$, [competition death]
			\item $\mu\left(\frac{b_{i-1} + b_{i+1}}{2}\right)$, [extrinsic birth-rate]
		\end{itemize}
	\item We use 3 groups of PPP's where every group represents an event. 
		
		\begin{itemize}
			\item $N_t^{b_i}$
			\item $N_t^{d_i}$
			\item $N_t^{\bar{c}_i}$
		\end{itemize}
	where $\bar{c} = \left(\sum_{j=1}^N \frac{c_{\cdot,j}}{K}x_j\right)_i$. Therefore we get 3N processes running that compete about the first one occurring with each one triggering an death/birth for an trait.
	\item With respect to the fact that the distribution of the $N_t$ changes with the size of the population we can think of an reset of the parameters of $N_t$ due to the fact that the increments are exponentially distributed and therefore are memoryless (markov property)
	\item The use of coloring one trait was (only $\to$ ask later) to explain the superposition of the PPP associated with the simulation to extract the occured event from the PPP's \\
	\[\to N_t^{total_{i}} = N_t^{b_i + d_i + \bar{c}_i} = N_t^{b_i} + N_t^{d_i} + N_t^{\bar{c}_i}\]
Therefore we would decide:
\begin{equation}
	X_i^{total} = 
	\begin{cases}
		\textrm{coloring d} & \textrm{with prob. p}\\
		\textrm{coloring b} & \textrm{with prob. q} \\
		\textrm{coloring }\bar{c} & \textrm{with prob. 1-p-q}  
	\end{cases}
\end{equation}
with:
\begin{align*}
	p = \frac{d_i}{d_i + b_i + \bar{c}_i} && q = \frac{b_i}{d_i + b_i + \bar{c}_i} && 1-p-q = \frac{\bar{c}_i}{d_i + b_i + \bar{c}_i}
\end{align*}
\end{itemize}

\section{Second meeting (22.04): Pseudocode}
First thing to mention is that the Pseudocode snippets are marked as "`Algorithm"', but in fact they are just functions and I don’t know yet how to change the name in this particular LaTeX environment. Also I use a "`="' instead of "`$\leftarrow$"' because I think it provides better readability.\\
The following Pseudocode will contain many function-calls. Every function can be identified as a verb, and objects or local variables are nouns. There will also be one Boolean "`isBorn"' which is an adjective.\\
Generally the functions have no return values because in this situation we tell functions to do something (not ask). Means we pass a task to them. There will be no requests for return values.\\
One other thing to mention is that the function names can get long, but they will (or should) always say what the function does. Not more or less.\\
The function-body should always follow a rule called "`pretty much what you expected"'. Some functions do violent this rule slightly. They are usually more than 6 lines and will be changed later.\\
First we start with the main Step of the Algorithm and continue with further explaining of the used functions. When a new function appear, it will be explained directly below it. Also we seperate this section in 3 parts, each one is dedicated to one of the functions used in this following EvolutionStep():
\begin{algorithm}[H]
	\caption{EvolutionStep()}
	\begin{algorithmic}[1]
		\REQUIRE -
		\ENSURE{A full evolution Step happened}
		\STATE calculateEventRates();
		\STATE sampleEventTime();
		\STATE changeATrait();
	\end{algorithmic}
\end{algorithm}
This function does a full evolution step. First thing to do is to calculate the Event rates with "`calculateEventRates"', than we sample an exponential time with our current rate parameters with "`sampleEventTime"' and finish the Step with changing a Trait with "`changeATrait"'. \\
Most functions-calls should not need to be explained, that’s why I leave this explanations out in following comments.\\
This function will be improved later with not calculating the Rates in every new step, rather than updating them with the previous changes. \\
	
\subsection{Calculating total-event rates}
We will encounter 2 classes called "`Trait"' and "`Events"'. They are so called Data Classes and usually mainly store data.\\
They are visible at all time and can be used like global variables. \\
In this first part of calculating total-event rates we only need to introduce the "`Trait"' class which will be used as an array of traits "`Trait[$i\le n$]"' with n beeing the maximum number of traits. An Trait Object has attributes that can be accessed through a dot operator like "`Trait[i].Members"' what would be "`the Members of Trait i"'.\\
This is a listing of all attributes in one Trait Object:\\
\textcolor[rgb]{0,0,0.55}{\textbf{class Trait}
\begin{itemize}
	\item BirthRate
	\item TotalBirthRate
	\item DeathRate
	\item TotalDeathRate
	\item TotalTraitRate
	\item TotalEventRate - [static]
	\item CompDeathRate[i][j] - [static]
\end{itemize}
}

Here is much work with Superposition of the PPP included. We summarize the sum of birth-rates from members within a trait to the "`TotalBirthRate"' (mutation included), same for "`TotalDeathRate"' (competition included). \\
The "`TotalTraitRate"' is the summed  "'TotalBirthRate"' and "`TotalDeathRate"' and means the total rate of events for a specific trait. \\
"`TotalEventRate"' and "`CompDeathRate"' are static, this means that they are the same for all initialized Trait objects. They (all items from the array) access the same variable for this. "`TotalEventRate"' is the same as usual and "`CompDeathRate"' is the competition-matrix with according rates.\\	
\begin{algorithm}[H]
	\caption{calculateEventRates()}
	\begin{algorithmic}[1]
		\REQUIRE -
		\ENSURE{All (total)Rates will be set}
		\FOR{i=0 \TO n-1}
			\STATE calculateTotalDeathRateOf(i)
		\ENDFOR
		\STATE calculateTotalBirthRates(0);
		\STATE calculateTotalEventRate();
	\end{algorithmic}
\end{algorithm}
In the next function we will manipulate attributes of the Trait Objects. The mutation will be accessed without and Traitindex: "`Trait.Mutation"' because it is static and therefore the same for all Objects.
\begin{algorithm}[H]
	\caption{calculateTotalBirthRates(StartIndex: i)}
	\begin{algorithmic}[1]
		\REQUIRE int i
		\ENSURE{Total birthrate of Trait "`i"' will be set (recursively)}
		\STATE Trait[i].TotalBirthRate = (Trait[i].Members)$\cdot$(Trait[i].BirthRate)
		\IF{$i < n-1$}
			\STATE calculateTotalBirthRates(i+1)
			\STATE Trait[i].TotalBirthRate += $\frac{Trait.Mutation}{2}\cdot Trait[i+1].TotalBirthRate $
		\ENDIF
		\IF{$i > 0$}
			\STATE Trait[i].TotalBirthRate += $\frac{Trait.Mutation}{2}\cdot Trait[i-1].TotalBirthRate $
		\ENDIF
	\end{algorithmic}
\end{algorithm}
In Algorithm 3 in line 3 is used recursion, because this improves the calculation speed a lot, although it slightly makes code less intuitive.

\begin{algorithm}[H][H]
	\caption{calculateTotalDeathRateOf(TraitIndex: i)}
	\begin{algorithmic}[1]
		\REQUIRE int i
		\ENSURE{Total deathrate of Trait "`i"' will be set}
		\STATE Trait[i].TotalDeathRate = 0;
		\STATE addTotalIntrinsicDeathRateOf(i);
		\STATE addTotalCompetitionDeathRateOf(i);
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
	\caption{addTotalIntrinsicDeathRateOf(TraitIndex: i)}
	\begin{algorithmic}[1]
		\STATE Trait[i].TotalDeathRate = (Trait[i].DeathRate) $\cdot$ (Trait[i].Members)
	\end{algorithmic}
\end{algorithm}
\begin{algorithm}[H]
	\caption{addTotalCompetitionDeathRateOf(TraitIndex: i)}
	\begin{algorithmic}[1]
		\FOR{j=0 \TO n-1}
			\STATE Trait[i].TotalDeathRate += (Trait.CompDeathRate[i,j])$\cdot$(Trait[j].Members);
		\ENDFOR
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
	\caption{calculateTotalEventRate()}
	\begin{algorithmic}[1]
		\REQUIRE -
		\ENSURE{Current Totaleventrate is set}
		\FOR{i=0 \TO n-1}
			\STATE Trait[i].TotalTraitRate = Trait[i].TotalBirthRate \\ 
			\noindent\hspace*{36mm}+ Trait[i].TotalDeathRate;
			\STATE Trait.TotalEventRate += Trait[i].TotalTraitRate;
		\ENDFOR
	\end{algorithmic}
\end{algorithm}

\subsection{Sampling the next event-time}
Here will appear a, not yet mentioned, object that will not be explained further, called Dice. The Dice Object will provide a uniform or exponential random Variable.\\
\begin{algorithm}[H]
	\caption{sampleEventTime()}
	\begin{algorithmic}[1]
		\REQUIRE -
		\ENSURE{First ringing Eventclock has been sampled}
		\STATE double Parameter = Trait.TotalEventRate;
		\STATE double newEvent = this.Dice.RollExpDice(Parameter);
		\STATE Events.EventTimes.push(newEvent);
	\end{algorithmic}
\end{algorithm}
Here we use Dice.RollExpDice($\lambda$) to get $X\sim exp(\lambda)$. The same is possible for  Dice.RollUnifDice($\lambda$) to get $X\sim Unif[0,\lambda]$.\\

\subsection{Changing a trait}
Here we will work with the actual Events taking place. For this purpose i introduce the Events class like before the Trait class:\\
\textcolor[rgb]{0,0,0.55}{\textbf{class Events}
\begin{itemize}
	\item Dice
	\item EventTimes[i]
	\item ChosenTrait[i]
	\item isBirth[]
\end{itemize}
}
The EventTime, ChosenTrait and isBirth are so called vectors. They are dynamic containers and we need to push an item into them to append it to the last entry.
\begin{algorithm}[H]
	\caption{changeATrait()}
	\begin{algorithmic}[1]
		\REQUIRE -
		\ENSURE{make a change to the Population with current Parameters}
		\STATE choseTraitToChange();
		\STATE choseEventType();
		\STATE executeEventTypeOnTrait();
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
	\caption{choseTraitToChange()}
	\begin{algorithmic}[1]
		\REQUIRE -
		\ENSURE{Trait is chosen for changing}
		\STATE double Parameter = Trait.TotalEventRate;
		\STATE double HittenTrait = Dice.rollUnif(Parameter);
		\FOR{i = 1 \TO n-1}
			\IF{HittenTrait $\le$ Trait[i].TotalEvent}
				\STATE this.ChosenTrait.push(i);
				\STATE break;
			\ENDIF
			\STATE HittenTrait -= Trait[i].TotalEvent;
		\ENDFOR
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
	\caption{choseEventType()}
	\begin{algorithmic}[1]
		\REQUIRE -
		\ENSURE{Decision for Birth or Death is made}
		\STATE int i = Events.ChosenTrait.lastentry();
		\STATE double EventType = Dice.rollUnif(Trait[i].TotalTraitRate);
		\IF{EventType $\le$ Trait[i].TotalBirthRate}
			\STATE Events.isBirth.push(true);
		\ELSE
			\STATE Events.isBirth.push(false);
		\ENDIF
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
	\caption{executeEventTypeOnTrait()}
	\begin{algorithmic}[1]
		\REQUIRE -
		\ENSURE{Chosen event will occur on chosen trait}
		\IF{isBirth}
			\STATE Trait[ChosenTrait.lastentry()] += 1;
		\ELSE
			\IF{ChosenTrait.Members $>$ 0}
			\STATE Trait[ChosenTrait.lastentry()] -= 1;
			\ENDIF
		\ENDIF
	\end{algorithmic}
\end{algorithm}
\listofalgorithms

\newpage
\section{Thrid and Fourth meeting (Di 20.05 and 13.05): Graphical plans - afterwards}
Zunächst habe nicht meine bisherigen Fortschritte präsentiert. Dazu gehörte ...\\
Außerdem haben wir die graphischen Ansprüche an das Programm besprochen.
Dabei wurden folgende Ergebnisse erzielt:
\begin{itemize}
\item Man sollte eine gute Möglichkeit haben die Parameter im Programm einsehen zu können und auch eine gute Möglichkeit Daten zu laden.
\item Was besonders wertvoll ist, wäre eine Möglichkeit neue Instanzen zu generieren. Dabei hat sich jedoch das Problem gestellt dass es keine einfache Konsole mit simplem einseitigen Output und Input gibt, da man während einer Instanzgenerierung auch weiterhin mit dem Hauptfenster interagieren könnte. Das Problem wurde etwas umständlich über eine kontrollierte Deaktivierung der anderen Interfaceelemente gelöst.
\end{itemize}
Zur Darstellung des Graphen wurde folgendes gesagt:
\begin{itemize}
\item Es ist keine "{}Filmfunktion"{} gewünscht. Stattdessen sollte man einen Plot generieren und in diesen hereinzoomen und mit der Maus ziehen können.
\item Außerdem ist eine Legende gewünscht die eine Übersicht über alle Graphen bietet. 
\item Um die Graphen später vergleichen zu können sollte es eine Möglichkeit geben den Graph zu speichern.
\end{itemize}

\newpage
\section{Fifth meeting (Fr 30.05): Improvements - afterwards}
An diesem Tag habe bloß einige Änderungen vorgestellt und sichergestellt dass alle Funktionen ordnungsgemäß laufen:
\subsection{Graphische Änderungen}
Das waren hoffentlich alle optisch merklichen Änderungen:
\begin{itemize}
\item Ich habe eine Checkbox hinzugefügt die eine Option für sinnvollen Abbruch bietet. Diese Funktion prüft ob sich beide Populationen in einer $/epsilon$ Umgebung um den erwarteten Zustand befindet und stoppt anschließend die Iterationen. Zu Gunsten der Übersicht werden noch mal 1/3 der Anzahl bisher gemachten Iterationen angefügt.\\
Zu diesem Zeitpunkt ist $\epsilon = \frac{5}{\sqrt{K}}$.
\item Es wurde ein Anzeigefehler behoben der für Geburts- und Todesraten immer nur die Populationsgrößen der Eigenschaften angezeigt hat.
\item Auf dem Plotfenster habe ich ein Label mit den gemachten Iterationen hinzugefügt. Weiterhin findet sich dort jetzt auch ein Feld wo man einen Dateinamen eingeben kann der einem gespeichterten Bild dienen soll welches man mit dem neuen "{}save Image"{} Button erstellen kann. Das Bild wird zur Zeit als .png und .pdf gespeichert.
\item Die x-Achsenbeschriftung lautet nun nicht mehr Millisekunden sondern "{}Time"{}. Grund dafür ist dass ich nicht sicher bin welche Zeit unsere exponentielle Uhr ausgibt. Jedoch habe ich sie der Übersicht halber nicht mehr durch 1000 geteilt, da bei den gewünschten Instanzen ausreichend große Zeiten angenommen werden.
\item Zuletzt wurde noch bei der Legende der für die k-te Erwartete Eigenschaft "{}k. Expected"{} zusätzlich der konvergierte Wert angezeigt "{}k. Exp: 1.048"{}.
\end{itemize}

\subsection{Interne Änderungen}
\begin{itemize}
\item Ich habe mehrere Arten der Datenspeicherung ausprobiert. Zunächst habe ich die Daten alle nacheinander in eine "{}Storage"{} Datei geschrieben um schließlich einzeln die Daten mit "{}addData"{} zum Graphen hinzuzufügen. Das schien mir jedoch an der "{}addData"{} Stelle und am Datastream zu aufwendig.  
Danach bin ich auf eine alternative mit "{}Jumped Steps"{} umgestiegen. Die Jumped Steps basieren darauf das maximal 10.000.000 Punkte gespeichert werden und auch wenn viel mehr Iterationen gemacht werden, so werden nur Äquidistante 10 mio Stützstellen geplottet. Der Gedanke dahinter war die nicht Unterscheidbarkeit des Graphen für das menschliche Auge.
\item Ich habe eine "{}GraphClass"{} hinzugefügt die alle Daten für das "{}PlotWindow"{} vorbereitet, so dass das Fenster nur noch darauf zugreifen muss. Damit habe ich eine Brücke zwischen den Fenstern und dem Plot geschlagen.
\item Eine der wichtigsten Änderungen ist das Hinzufügen des QThreads. Dieser gewährleistet dass der Plot die Fenster nicht einfrieren lässt. Die Berechnung kann für mehr als 1mio Punkte bereits merkliche Zeit (>3s) beanspruchen.
\item ...to do...
\end{itemize}

\subsection{bekannte Bugs}
Es gibt hier noch einen Bug der mit der Beschriftung der x-Achse zu tun hat. Ich weiß noch nicht wie man ihn reproduziert, aber er könnte die Achse um einen großen Faktor zu groß skalieren. Der Plot weißt jedoch das geplante Verhalten auf und dieser Bug tritt nur bei \"replots\", also dann auf wenn ein neuer Plot den alten überschreibt.

\newpage
\section{Sixth meeting (03.06): Introducing TSS}
Einführung in TSS
\begin{itemize}
\item Das erste war das Einfügen einer Tabelle oder Grafik die einen guten Überblick über die Fitness der Population bietet. Diese gibt Aufschluss darüber ob TSS ordnungsgemäßes Verhalten zeigen wird. Allgemein ist es aber auch gut zu sehen welche Population wie stark auf eine andere wirkt, daher vielleicht schon ohne TSS sinnvoll.\\
Um eine bessere Übersicht von ungewünschtem Verhalten zu zeigen werden Coexistenzen rot markiert. Später wird noch eine weitere grünliche Färbung angezeigt die eine Verdrängungswahrscheinlichkeit darstellt.
Dieses Feature wird in beiden Programmen vorhanden sein.\\
Die verwendete Formel zur Berechnung der Fitness war \[ f_{x,y} = b_x - d_x - c_{x,y}\cdot \bar{n_x}\]
mit:
\[ \bar{n_x} = \frac{b_x - d_x}{c_{x,x}}\]
Demnach wird auf der Diagonale stets eine Null erwartet. Bei dieser Rechnung tritt jedoch eine Subtraktion auf die Auslöschung verursacht. Zu diesem Zweck habe ich die dargestellte Zahl auf 14 stellen runden lassen.
\item Ein besseres Verständnis von TSS wäre nützlich. Dazu wurde mir aus [2] S.1135 empfohlen. Leider habe ich es bisher noch nicht geschafft es durchzuarbeiten. Es wird auf den nächsten Wochenplan kommen.
\item Außerdem wurde die Skalierung der Mutationswahrscheinlichkeit mit K angepasst so dass TSS realistisch laufen kann. Dabei wurde der Faktor $\frac{1}{K^{1.5}}$ gewählt weil es den notwendigen Schranken die in [2] S.1135 beschrieben werden genügt. Ein weiterer Punkt den man optimieren kann wäre es eine Option zur Eingabe eines eigenen Exponenten für K wäre eine mögliche Erweiterung.
\item In diesem Zustand ist es bereits Möglich einen TSS plot zu erzeugen. Jedoch wird die Zeit im Equilibrium tatsächlich berechnet was viel unnötige Rechenarbeit impliziert. Später solle eine lineare Interpolation bis zur ersten Mutation gemacht werden sobald das Equilibrium erreicht wird.  
\subsection{Bekannte Bugs}
Es ist ein Bug bisher übrig. Bisher kenne ich noch nicht den Ursprung, aber er äußert sich (meistens) durch einen Programmabsturz nachdem ich eine kleinere Instanz lade und anschließend TSS1 bzw eine größere Instanz lade. Der Plot wurde dabei noch nicht ausgeführt.
\end{itemize}
  
\newpage
\section{Seventh meeting (10.06): Bug fixing and interpolation of Equilibrium}
\subsection{Was ist geplant?}
Geplant ist:
\begin{itemize}
	\item Beheben eines Fehlers beim Laden der Instanzen. Dieser wurde im letzten Kapitel beschrieben.
	\item Eine lineare Interpolation der Population im Equilibrium. Die Funktion dazu wurde bereits geschrieben.
	\item Korrekte Ausarbeitung eines geeigneten Abbruchkriteriums für TSS Prozesse.
	\item Punkte an denen eine Mutation stattgefunden hat sollen idealerweise hervorgehoben werden. Z.B. durch kreuze oder ähnliches.
	\item Am Besten wäre noch eine Skalierung der Zeitachse während des Equilibriums. 
	\item Die Fitnessmatrix sollte bisher eine Bandmatrix sein weil es nur Mutationen zum Nachbarn gibt.
\end{itemize}

\subsection{Was habe ich gemacht?}
Konkret:
\begin{itemize}
	\item Bisher habe ich eine Neudefinition der "{}isNear()"{} Funktion gemacht. Diese gibt es nun als "{}isNearDimorph()"{}, "{}isNearMonomorph()"{} und "{}isNearTSS()"{}. Diese tun was man vom Namen her erwartet, wobei "{}isNearTSS()"{} prüft die Nähe zum Equilibrium bzw. es prüft ob die Population bereits auf das Equilibrium getroffen ist (mit Rücksicht auf Auslöschung bis zu einer Genauigkeit von $10^{-10}$) und ob die Population zur Zeit die einzig aktive ist. 
	\item Weiterhin existiert eine neue Version der "{}iterateGraphPoint()"{} Methode. Sie heißt "{}iterateMutationPoint()"{} und soll den Zeitpunkt der nächsten Mutation der Nachbarn berechnen. Anschließend soll dieser Zeitpunkt in der Zeitlinie gespeichert werden und dort eine Mutation auf der Population ausgeführt werden.
	\item Diese "{}iterateMutationPoint()"{} Funktion soll anschließend von einer neuen Funktion "{}makeTSSIterations()"{} nur dann ausgeführt werden, wenn die neue "{}isNearTSS()"{} eine Bestätigung liefert.
	All diese Änderungen wurden in der GraphClass gemacht und werden in "{}generateEvolution()"{} verwendet.
	\item Ein wichtiger Zusatz für die Berechnung der Geburtenrate wurde getroffen. Dabei wurde jetzt nicht mehr zu beginn $b(i)\cdot N(i) + MutationFromNeighbors$ gerechnet, sondern $b(i)\cdot N(i) \cdot (1-\mu) + MutationFromNeighbors$. Das ist bisher nicht aufgefallen weil $\mu$ für gewöhnliche dimorphe Prozesse immer Null war.
	\item Eine sehr wichtige Änderung sollte die Berechnung des monomorphen stabilen Zustands gelten. Wenn eine positive Mutationswahrscheinlichkeit vorliegt, so sinkt die Arteigene Geburtenrate um die Mutationswahrscheinlichkeit. Somit berechnet sich das Equilibrium im TSS durch \[\frac{b(x)\cdot (1-\mu) - d(x)}{c_{x,x}}\]
	\item NearTSS wurden die Grenzen geändert, so dass es jetzt eine Umgebung von 1/K um das Equilibrium gibt statt dem genauen Treffer. Das ist notwendig, weil es sein kann dass unser Equilibrium kein Vielfaches von 1/K ist, gewährleistet aber trotzdem die gröst mögliche Nähe zum Equilibrium.
	\item Es hat sich ein Bug ergeben der die Zeit falsch (bzw immer mit der ersten Rate) berechnet hat. Das wurde durch ein veraltetes "{}static"{} beim Ziehen der Würfelergebnisse verursacht.
	\item Ein weiteres Problem wurde behoben nach dem zufolge es noch keine ordentlich Anzeige für ein TSS gab, nachdem ein Trait zum ersten mal ausgestorben ist. Die Ursache lag in der "{}isNearTSS()"{} Funktion, daher wurde diese Überarbeitet.
	\item Es gab ein Problem weshalb der angezeigte stabile Zustand nicht bis zum Mutationspunkt durchgezogen wurde, sondern bereits sichtbar davor stoppte. Die Ursache war dass nur die Zeit bis zur nächsten Mutation als neuer Zeitpunkt gespeichert wurde, nicht aber die iterierte Zeit.
	\item Ich habe einen Bug behoben der das Programm manchmal zum Absturz brachte. Dabei handelte es sich wahrscheinlich um einen Speicherfehler, die genaue Ursache kenne ich nicht, aber ich konnte den Fehler beheben indem ich die Fitness Matrix "{}gecleart()"{} habe bevor sie erneut "{}resize()"{} aufruft.
\end{itemize}
todo
\begin{itemize}
 \item Es sollten direkte getter und setter auf die Trait und Event Members ausgeführt werden satt sie temporär zu speichern wie in "{}generateEvolution()"{}. 
\end{itemize}
\subsection{Bekannte Bugs}
\begin{itemize}
	 \item Der letzte Punkt des Graphen wurde nicht gespeichert. Außerdem sollte der Graph auch wenn nichts mehr für ihn passiert, trotzdem bis zum ende fortgesetzt werden. Dazu sollte der letzte Zeitpunkt nocheinmal mit dem Endzustand abgespeichert werden. 
	 \item Exp in der Legende sollte gesondert geändert werden.
	 \item Problem mit K-member K-expected und Darstellung beider.
\end{itemize}

\newpage
\section{Zweites Bachelorseminar}
	\subsection{Ziel}
		Das Ziel meiner Bachelorarbeit ist es ein Programm zu entwickeln welches eine Simulation eines BPDL und TSS Prozesses durchführen kann. Dies soll dem besseren Verständnis über BPDL und TSS Prozessen dienen und kann zu statischen Nachweisen verwendet werden. Gerade deswegen ist es wichtig sicherstellen zu können dass sich keine Fehler in die Implementation einschleicht. Dazu jedoch mehr im Kapitel "{}Korrektheit der Implementation"{}.
	\subsection{Model}
		Zunächst möchte ich das in der Simulation verwendete Model vorstellen.\\
		\begin{itemize}
			\item ? Dieses Modell soll eine Population beschreiben in der jedes Individuum ein Merkmal $ x \in X \subset \mathbf{R}^n $ hat. Wobei die Simulation $ X $ ein endlichen diskreten Merkmalsraum verwendet der hier der Einfachheit halber als Indexmenge $ X = \{1,\dots, n\} $ repräsentativ für eine Durchzählung der Merkmale steht.
			\item Jedes Individuum kann sich entweder asexuell fortpflanzen oder sterben
			\item Diese Ereignisse treten dabei in exponentiell verteilter Häufigkeit auf. Diese exponentiellen Ereignisse haben die folgenden Raten:
			\begin{itemize}
				\item b(x): Geburtenraten (Fortpflanzung) für ein Individuum mit Merkmal x.
				\item d(x): natürliche Todesrate
				\item c(x,y): Todesrate durch Wettbewerb zwischen zwei Individuen mit Merkmal x und y.
				\item $ \mu $: Mutationswahrscheinlichkeit für eine Mutation "{}auf die Nachbarn"{} mit je $ 50\% $ Wahrscheinlichkeit.
			\end{itemize}
			Durch Ausnutzung des Superpositions Prinzips (? und der Markoveigenschaft) können mehrere exponentielle Ereignisse zusammengefasst werden, so dass man z.B. eine Todesrate und eine Arteigene Geburtenraten erstellen kann:
			\begin{itemize}
			 	\item Arteigene Geburtenrate: $ b(x) \cdot (1 - \mu) + (b(x+1) + b(x-1)) \cdot \frac{\mu}{2}$
			 	\item Todesrate: $ d(x) + \sum_{i=1}^{N_t} c(x,x_i) $, wobei $ N_t $ die Anzahl der Individuen zum Zeitpunkt t ist und $ x_i $ das Merkmal des i-ten Individuums. Diese Rate kann praktischer dargestellt werden als:
			 	\item Todesrate: $ d(x) + \sum_{i=1}^{n} c(x,x_i) \cdot n_t(x_i) $, wobei $ n $ die Anzahl der Merkmale ist und $ n_t(x_i) $ die Anzahl der Individuen mit Merkmal $ x_i $ zur Zeit t.
			\end{itemize}
			Die Simulation soll die Entwicklung der Merkmale und nicht die Ereignisse der Individuen darstellen, daher ist es unpraktisch diese zu betrachten. Alternativ werden die Ereignisse zu denen von Merkmalen zusammengefasst:
			\begin{itemize}
				\item Geburtenrate des Merkmals x: \[ B(x) = b(x) \cdot (1 - \mu) \cdot n_t(x) + (b(x+1)\cdot n_t(x+1) + b(x-1)\cdot n_t(x-1)) \cdot \frac{\mu}{2} \]
				\item Todesrate des Merkmals x: 
				\[ D(x) = d(x) \cdot n_t(x) + n_t(x) \cdot \sum_{i=1}^{n} c(x,x_i) \cdot n_t(x_i) \]
			\end{itemize}
			\item Um in der Simulation für den Fall vieler Merkmale nicht auch genauso viele Zufalls variablen ziehen zu müssen, werden die Raten zusammengefasst bis nur noch eine exponentielle Uhr läuft.
			\begin{itemize}
				\item Ereignisrate des Merkmals x (Trait Rate):
					\[ TR(x) = B(x) + D(x) \]
				\item Totale Ereignis Rate (Total Event Rate): 
				\[ TER(x) = \sum_{x \in X} TR(x)\]
			\end{itemize}
			Mit der Totalen Ereignisrate gibt es jetzt eine Rate die es erlaubt eine Zufallsvariable für das Eintreffen einer Variable zu ziehen. Anschließend ist es nur noch erforderlich mit der Ziehung zwei weiterer Zufallsvairablen festzustellen welchem Merkmal welches Ereignis zukommt.
			\item Die Population wird durch die ZV $ \nu_t = \sum_{i = 1}^{N_t} \delta_{x_i}$ beschrieben.\\
			Dabei nimmt $ \nu_t $ Werte in $ M_F(X) = \{\sum_{i=1}^{n} \delta_{x_i} \} $.
			\item $ \nu_t $ ist ein Markov Sprung Prozess, $ \int_{x} \mathbbm{1}_{y}(x)\nu_t(dx)$.
			\item Der Generator des so definierten BPDL-Prozess $ \nu_t $ ist:
			\begin{align}
				L_{\phi(\nu)} &= \int_{x} b(x)(1-\mu)[\phi(\nu + \delta_x) - \phi(\nu)]\nu(dx)\\
							&+ \int_{x}\int_{\mathbb{R}^d} b(x)(\mu)[\phi(\nu + \delta_{x+z}) - \phi(\nu)] m(x,dz) \nu(dx)\\
							&+ \int_{x} d(x)[\phi(\nu - \delta_x) - \phi(\nu)]\nu(dx)\\
							&+ \int_{x} \left( \int_{X} c(x,y) \nu(dy) \right) [\phi(\nu - \delta_x) - \phi(\nu)]\nu(dx)
			\end{align}
			mit $ \phi: M_F \to \mathbb{R} $
		\end{itemize}
		\subsubsection{Normalisierung}
		...
		
		
	\subsection{Algorithmus}
	Der verwendete Algorithmus führt einen Sprung des Markov Sprung Prozesses ab dem zuletzt bekannten Zeitpunkt t aus. Die tatsächlich verwendete Funktion sieht im Code so aus:
	\begin{algorithm}[H]
		\caption{EvolutionStep()}
		\begin{algorithmic}[1]
			\REQUIRE -
			\ENSURE{A full evolution Step happened}
			\STATE calculateEventRates();
			\STATE sampleEventTime();
			\STATE changeATrait();
		\end{algorithmic}
	\end{algorithm}
	
	Etwas ausführlicher werden folgende Berechnungen angestoßen:
		
	\begin{algorithm}[H]
		\caption{EvolutionStep()}
		\begin{algorithmic}[1]
			\REQUIRE -
			
			\ENSURE{A full evolution Step happened}
			\STATE ---$>$calculateEventRates();
			\STATE calculateTotalDeathRates()
			\STATE calculateTotalBirthRates()
			\STATE calculateTotalEventRate()
			\STATE ---$>$sampleEventTime();
			\STATE sampleEventTime();
			\STATE ---$>$changeATrait();
			\STATE choseTraitToChange();
			\STATE choseEventType();
			\STATE executeEventTypeOnTrait();
		\end{algorithmic}
	\end{algorithm}
	Schließlich der Ablauf der tatsächlichen Berechnung:
	\begin{algorithm}[H]
		\caption{EvolutionStep()}
		\begin{algorithmic}[1]
			\ENSURE{A full evolution Step happened}
			\REQUIRE $ t, X = \{0,\dots, n-1\} $
			\STATE ---$>$calculateEventRates();
			\FOR{ $ x \in X $ }
				\STATE $  D(x) := n_t(x) \cdot \left( d(x) + \sum_{y \in X} c(x,y) \cdot n_t(y) \right) $
				\STATE $ B(x) := \underbrace{b(x) \cdot (1 - \mu) \cdot n_t(x)}_{arteigene}  $
				\IF{$ x > 0 $}
					\STATE $ B(x) += \underbrace{b(x-1)\cdot n_t(x-1)}_{Mutation Links} \cdot \frac{\mu}{2} $
				\ENDIF
				\IF{$ x < n-1 $}
					\STATE $ B(x) += \underbrace{b(x+1)\cdot n_t(x+1)}_{Mutation Rechts} \cdot \frac{\mu}{2} $
				\ENDIF
				\STATE $ TotalTraitRate(x) = B(x) + D(x) $
			\ENDFOR
			\STATE $ TotalEventRate := \sum_{x \in X} TotalTraitRate(x) $
			
			\STATE ---$>$sampleEventTime();
			\STATE sample $ Z \sim exp(TotalEventRate) $
			\STATE $ t += Z $
			
			\STATE ---$>$choseTraitToChange();
			\STATE sample $ Y \sim U(0,TotalEventRate) $
			\FOR{$ x \in X $}
				\IF{$ Y \le TotalTraitRate(x) $}
					\STATE $ ChosenTrait := x $
					\STATE break
				\ENDIF
				\STATE $ Y -= TotalTraitRate(x) $
			\ENDFOR
			
			\STATE ---$>$choseEventType();
			\STATE sample $ Y \sim U(0,TotalTraitRate(ChosenTrait)) $
			\IF{$ Y \le B(ChosenTrait) $}
				\STATE isBirht := true
			\ELSE
				\STATE isBirth := false
			\ENDIF
			
			\STATE ---$>$executeEventTypeOnTrait();
			\IF{isBirth}
				\STATE $ n_t(ChosenTrait) += 1 $
			\ELSE
				\IF{$ n_t(ChosenTrait) \ge 0 $}
					\STATE $ n_t(ChosenTrait) -= 1 $
				\ENDIF
			\ENDIF
		\end{algorithmic}
	\end{algorithm}

	
	\subsection{Simulation}
		\subsubsection{Aufgabenteilung und Flexibilität}
		Drei Module, jedes hat seine eigene Aufgabe.
		\subsubsection{Diagramme}
		Klassendiagramm\\
		Aktivitätsdiagramm
		\subsubsection{Graphische Darstellung}
		Kein Film, zoom, Skalierung, speichern der Bilder etc...
	\subsection{Programmlayout}
		\subsubsection{Laden der Parameter}
		Beste Option ist lesen der Parameter aus Dateien. Dabei wurde gewünscht dass kein direkter Zugriff des Nutzers auf die Dateien notwendig sein sollte um alle verwendeten Parameter anzuzeigen.
	
		\subsubsection{Erstellen einer Testinstanz}
		Da generell der Umgang mit Dateien und speziell auf das Programm zugeschnittenen Regeln für das Beschreiben dieser unerwünscht ist, habe ich eine Möglichkeit gesucht Dateien über das Programm mit Benutzereingabe erstellen zu lassen.
		
		\subsubsection{Präsentation des Programms}
		
	\subsection{Korrektheit der Implementation}
	(Korrektheit des Algorithmus nicht notwendig bzw möglich)
	Das viel interessantere ist die Korrektheit der Implementation. Diese ist generell mit steigender Komplexität schwerer zu prüfen (besonders bei Zufallsbedingten Simulationen).\\
	Daher habe ich das Prinzip der "{}Testgetriebene Entwicklung"{}  (Test Driven Develeopment) verwendet.\\
	Spätere statische Möglichkeiten
	
	\subsection{Warum ist es vielleicht schwierig simple Mechanik einzupflegen?}
	Wie man sich vielleicht denken kann sind viele kleine Features an und für sich sehr simpel.
	Unglücklicherweise gibt es viele kleine solche Features und Daten die mit dem Programm verbunden wären. 

\newpage
\section{Weitere geplante Punkte}
\subsection{große Verbesserungen}
	\begin{itemize}
		\item 	Es wäre sinnvoll wenn es eine Möglichkeit gibt die angestrebten stabilen Zustände als Option auszuwählen welche angezeigt werden sollten. Dabei sollte die Beschriftung "{}Dimorph"{} oder "{}Monomporph"{} darin auftauchen.
		\item Es sollte das aktuell verwendete K angezeigt werden.
		\item dynamisches Abbruchkriterium welches für alle TSS Instanzen angemessen terminiert.
		\item Dokumentation zu Programmcode und Bedienung
		\item Anpassen der neuen Geburten und Equilibrien.
		\item Evtl. Abfrage beim Überschreiben von Dateien
		\item Instanzexplorer
		\item GraphClass aufräumen (RangeCheck etc.)
		\item Unit Tests anpassen und erweitern
	\end{itemize}

\subsection{kleine Verbesserungen}
\begin{itemize}
\item Items in der Tabelle sollten zentrieren
\item stabiler Zustand weniger Aufdringlich (z.B. größerer Abstand zwischen Strichen und geringere Strichstärke)
\item Feedback beim Speichern eines Bildes
\end{itemize}



\end{document}
