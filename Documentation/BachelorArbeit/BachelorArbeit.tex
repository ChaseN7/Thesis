\documentclass[11pt, a4paper, german]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{color}
%\usepackage{algorithmicx}
%\usepackage[compatible]{algpseudocode}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{makeidx}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{bbm}
\usepackage[ngerman]{babel}
\usepackage{BA_Titelseite}
\usepackage[colorlinks=false, pdfborder={0 0 0}]{hyperref}
\bibliographystyle{unsrt}

%Namen des Verfassers der Arbeit
\authornew{Boris Prochnau}

%Geburtsdatum des Verfassers
\geburtsdatum{22. Dezember 1989}
%Gebortsort des Verfassers
\geburtsort{Tartu}
%Datum der Abgabe der Arbeit
\date{\today}

%Name des Betreuers
% z.B.: Prof. Dr. Peter Koepke
\betreuer{Betreuer: Prof. Dr. Anton Bovier,\\ Dipl. Martina Baar und Dr. Loren Coquille}
%Name des Instituts an dem der Betreuer der Arbeit tätig ist.
%z.B.: Mathematisches Institut
\institut{Institut für Angewandte Mathematik}
%Titel der Bachelorarbeit
\title{Simulation normalisierter BPDL Prozesse und TSS Prozesse}
%Do not change!
\ausarbeitungstyp{Bachelorarbeit Mathematik}



\begin{document}

\maketitle
\tableofcontents



\clearpage
\section{Einleitung}
Ziel dieser Bachelorarbeit ist die Entwickelung eines Programms, das die Dynamik einer Population simulieren kann. Dar"uber hinaus wird die Erweiterung zu einem zweiten Programm vorgestellt welches besonders interessante Populationen, genannt "{}Trait Substitution Sequences"{}, simulieren kann.\\

Alle Simulationen basieren auf dem Modell, dass jedes Lebewesen einer Population (z.B. Pflanzen) ein bestimmtes Merkmal tr"agt. Bestimmt wird ein Merkmal durch Todesraten und einer Fortpflanzungsrate. Die Todesraten sind eine einfache nat"urliche Todesrate und eine durch Wettbewerb mit jedem anderem Individuum. Das hei"st diese Rate steigt mit der Anzahl der konkurrierenden Individuen.\\
Schlie"slich ist es jedoch die Entwicklung der Population und nicht der Individuen die simuliert werden soll. Deshalb kann man im simulierten Prozess zwar Tode und die Geburten verfolgen, aber nicht welches Individuum dieses Ereignis ausl"ost. Der "Ubergang zu dieser Sichtweise wird n"aher im 2. Kapitel beschrieben.\\

Das Programm sollte Parameter einlesen k"onnen und eine Oberfl"ache bieten auf die Simulation graphisch angezeigt wird. Tats"achlich wird das Programm mehr bieten und flexible Erweiterungsm"oglichkeiten beinhalten.\\
Die graphische Darstellung des Prozesses soll die M"oglichkeit bieten beobachten zu k"onnen ob sich ein Merkmal unter anderen Durchsetzten kann, es einen stabilen Zustand annimmt oder sicher dem Tod entgegen strebt.\\
\textit{N"aheres zum erwarteten Verhalten der Simulation fehlt noch}\\

Im letzten Teil werde ich noch kurz die Erweiterung auf TSS Prozesse vorstellen. Darin soll nicht nur das besonders interessante Verhalten vom Wechsel des dominanten Merkmals behandelt werden, sondern es wird eine verbesserte Laufzeit durch Interpolation vorgestellt die eine effiziente Simulation trotz sehr gro"ser Zeit und besonders pr"aziser Betrachtung von Aktionsreichen Gebieten anbietet.


%Dabei ist das Interesse besonders bei normalisierten BPDL Prozessen und schließlich auch bei TSS (trait subsitution sequence) Prozessen.\\
%Dabei reicht es nicht einfach eine Implementierung zu machen, denn durch die Zufallseigenschaft lässt sich nicht so einfach die Korrektheit verifizieren. Gerade bei TSS Prozessen ist die Anzahl der Mutationen und deren Abstände und Invasionschancen entscheidend.\\
%Zu diesem Zweck wird ein Teil der Arbeit diese Problemstellung behandeln.

\clearpage
\section{Modell}
Das verwendete Model wurde in \cite{Bolker_Spatial_moment,Bolker1997179,raey_Dieckmann_Law} eingef"uhrt. Dieses nutzt die drei grundlegenden Mechanismen von Darwins Evolutionslehre: Vererbung, Variation (Mutationen) und Selektion durch Wettbewerb um eine Menge von Merkmalen f"ur Individuen zu beschreiben. Diese bestimmen die F"ahigkeit des Individuums zu "uberleben und sich fortzupflanzen. Der daraus resultierende zeitstetige Sprung-Prozess wird BPDL Prozess (nach Bolker, Pacala, Dieckmann und Law) genannt.\\
Ziel wird es sein zwei spezielle BPDL-Grenzwert-Prozesse simulieren zu k"onnen.
	\subsection{Grundlagen}
	Sei $ X $ der Raum der Merkmale. Jedes Individuum hat genau ein solches Merkmal $ x \in X $. Der Einfachheit halber sei X eine Indexmenge: $ X = \{1,\dots, n\} $ repräsentativ für eine Durchzählung der Merkmale und im folgenden seien $ x,y \in X $ zwei solche Merkmale. Au"serdem gilt:
	\begin{itemize}
		\item Jedes Individuum kann sich asexuell fortpflanzen oder sterben.
		\item Fortpflanzungs- und Todeszeitpunkte k"onnen durch sogenannte exponentielle Uhren beschrieben werden (wie in \cite[S. 3]{fournier2004microscopic}). Diese Uhren haben exponentiell verteilte Weckzeiten. Durch die Gedächtnislosigkeit der Exponentialverteilung und wegen des Wettbewerbs, können und müssen alle Uhren nach dem ersten Klingeln neu gestellt werden. Durch den Einfluss des Wettbewerbs ist jede Todesrate abh"angig von der Anzahl an Konkurrenten die durch das zuerst eintretende Ereignis beeinflusst wird. 
		\item Die Fortpflanzung eines Individuums mit Merkmal $ x $ kann jedoch auch in der Geburt eines Individuums mit Merkmal $ y $ resultieren. Das wird durch die Mutationswahrscheinlichkeit kontrolliert.
	\end{itemize}
	Sp"ater wird deutlich dass die Zur"uckstellbarkeit der Uhren entscheiden ist um die Sichtweise von der Ebene des Individuums auf die der gesamten Population zu heben.\\
	Diese Todes und Fortpflanzungs- Ereignisse eines Individuums haben feste Raten die das dazugeh"orige Merkmal beschreiben.\\
	
	\begin{tabular}{r p{26em}}
		$ b(x) $: & Ist die Geburtenraten durch ein Individuum mit Merkmal $ x $.\\
		$ d(x) $: & Ist die natürliche Todesrate.\\
		$ c(x, y) $: & Ist die Todesrate durch Wettbewerb zwischen Individuen mit Merkmal x und y.\\
		$ \mu $: & Ist die Mutationswahrscheinlichkeit "{}auf die Nachbarn"{} mit je $ \frac{\mu}{2} $ pro Nachbar. \\
	\end{tabular}\\

	Schlie"slich lassen sich durch Superpositionsprinzip der Exponentialverteilung die beiden Todesraten zu einer gemeinsamen Todesrate zusammenfassen oder die arteigene Geburtenrate beschreiben.\\
	
	\begin{tabular}{ r p{18em} }
		$ b(x) \cdot (1 - \mu) $ & Ist die arteigene Geburtenrate eines Individuums mit Merkmal $ x $, also mutationsfreie Geburten.\\
		$ d(x) + \sum_{i=1}^{N_t} c(x, x_i) $ & Ist die gesamte Todesrate eines Individuums mit Merkmal x (mit $ N_t := $ \#Individuen zur Zeit t mit Merkmal $ x $ und $ x_i $ das Merkmal des i-ten Individuums).\\
		$ d(x) + \sum_{y=1}^{n} c(x,y) \cdot n_t(x) $ & Wie oben, nur mit $ n := $ \#Merkmale, und $ n_t(x) :=$ \#Individuen zur Zeit t mit Merkmal $ x $
	\end{tabular}\\

	Weil die Simulation die Entwicklung der Merkmale und nicht die Ereignisse der Individuen darstellt, ist es unpraktisch weiterhin die Raten jedes Individuums zu berechnen. Die letzte Darstellung der Todesrate ist z.B. praktischer f"ur die Betrachtung der Population durch den Fokus auf die Merkmale.  "Ahnlich k"onnen weitere Ereignisse zusammengefasst werden, so dass man z.B. eine Todesrate und eine arteigene Geburtenraten der Merkmale erstellen kann:
	
	\begin{itemize}
		\item Fortpflanzungsrate des Merkmals $ x $: 
		\[ B_1(x) = b(x) \cdot n_t(x) \]
		Oder alternativ die arteigene Geburtenrate (Wachstumsrate) des Merkmals $ x $: 
		\begin{align*}
			B_2(x)  & = (1 - \mu) \cdot b(x) \cdot n_t(x)\\
				  & + \frac{\mu}{2} \cdot b(x+1) \cdot n_t(x+1) \cdot \mathbbm{1}_{x<1}\\
				  & + \frac{\mu}{2} \cdot b(x-1) \cdot n_t(x-1) \cdot \mathbbm{1}_{x>1}
		\end{align*}
		\item Todesrate des Merkmals $ x $: 
		\[ D(x) = d(x) \cdot n_t(x) + n_t(x) \cdot \sum_{y=1}^{n} c(x,y) \cdot n_t(y) \]
	\end{itemize}
	Das entspricht 2 wesentlichen exponentiellen Uhren pro Merkmal. Eine für Tod und eine für Geburt innerhalb des Merkmals.\\
	\textit{F"ur die Simulation ist eine Gesamtrate für das Eintreten eines Ereignisses praktischer. Auf diese Weise wird nur auf das Eintreffen einer Uhr gewartet.}
	\begin{itemize}
		\item Ereignisrate des Merkmals $ x $ (Trait Rate):
		\[ TR(x) = B(x) + D(x) \]
		\item Totale Ereignis Rate (Total Event Rate): 
		\[ TER = \sum_{x \in X} TR(x)\]
	\end{itemize}
	Mit der Totalen Ereignisrate gibt es eine Rate die es erlaubt eine Zufallsvariable für das Eintreffen einer Variable zu ziehen. Anschließend ist es nur noch erforderlich (mit der Ziehung zwei weiterer Zufallsvairablen) festzustellen welchem Merkmal welches Ereignis zukommt. Das Zusammenfassen der Raten vereinfacht es dem Programm sp"atere Auswertungen und Funktionen bereitzustellen. So l"asst sich z.B. aus der Geburtenrate (Wachstumsrate) eines ausgestorbenen Merkmals die Mutationsrate ablesen, ohne weitere Berechnungen machen zu m"ussen.\\
	
	\subsection{BPDL Prozess}
	Die auf dem vorhergehenden Modell basierende Population wird durch die Zufallsvariable
	\[ \nu_t = \sum_{i=1}^{N_t} \delta_{x_i}, \quad x_i := \text{Das Merkmal des i-ten Individuums} \]
	beschrieben. Sie bildet Merkmale auf die Anzahl ihrer Repr"asentanten ab.\\
	Mit Zeitpfaden ist $ \nu_t $ ein stochastischer Prozess, genauer ein Markov Sprung Prozess auf dem Raum:
	\[ \nu_t \in M_F(X) = \left\{ \sum_{i=1}^{n} \delta_{x_i}, n \in \mathbb{N}, x_1, \dots, x_n \in X \right\} \]
	Man erkennt leicht die Sprungeigenschaft:
	\[ \int_X 1 \text{ } \nu_t(dx) = N_t 
	\text{ und }
	\int_X \mathbbm{1}_y(x) \text{ } \nu_t(dx) = n_t^{y} \]
	Normalerweise geh"ort zum Model des BPDL Prozesses, dass die Mutationen auf einem beliebigen Merkmal (nicht nur den Nachbarn) landen k"onnen und der Raum der Merkmale nicht unbedingt diskret sein muss. Eine Mutationswahrscheinlichkeit h"angt in diesem Fall vom Merkmal ab, also $ \mu(x) $. Und der Mutant hat dann Merkmal $ x + h $, wobei h eine zentrierte Zufallsvariable mit Dichte $ m(x,dh) $ auf $ (X - x) $ ist.
	F"ur einen solchen Prozess w"are der Generator definiert als:
	\begin{align*}
		L_{\phi(\nu)} &= \int_{X} b(x)(1-\mu)[\phi(\nu + \delta_x) - \phi(\nu)]\nu(dx)\\
					  &+ \int_{X}\int_{\mathbb{R}^d} b(x) \cdot \mu [\phi(\nu + \delta_{x+z}) - \phi(\nu)] m(x,dz) \nu(dx)\\
				  	  &+ \int_{X} d(x)[\phi(\nu - \delta_x) - \phi(\nu)]\nu(dx)\\
				 	  &+ \int_{X} \left( \int_{X} c(x,y) \nu(dy) \right) [\phi(\nu - \delta_x) - \phi(\nu)]\nu(dx)
	\end{align*}
	mit $ \phi: M_F \to \mathbb{R} $\\
	Mit unserem diskreten Raum X und der konstanten Mutationswahrscheinlichkeit zu Nachbarn vereinfacht sich der Generator. Der f"ur unser Model angepasster Generator hat somit folgende Form:
	\begin{align*}
		L_{\phi(\nu)} &= \sum_{i = 1}^{\infty} b(x_i)(1-\mu)[\phi(\nu + \delta_{x_i}) - \phi(\nu)] \cdot n(x_i)\\
		&+ \sum_{i \sim j} n(x_i) \cdot b(x_i) \cdot \mu \cdot 
		 [\phi(\nu + \delta_{x_j}) - \phi(\nu)] \cdot n(x_i)\\		 
		&+ \sum_{i = 1}^{\infty} (d(x) + \sum_{j = 1}^{\infty} c_{i,j} \cdot n(x_j))[\phi(\nu - \delta_x) - \phi(\nu)] \cdot n(x_i)\\
	\end{align*}
	mit $ \phi: M_F \to \mathbb{R} $ und $ n(x_i) := $ Anzahl Individuen mit Merkmal $ x_i $.\\	


\clearpage
\section{Eigenschaften des BPDL Prozesses\\ - anderer Name?}
In diesem Kapitel werden Eigenschaften des Prozesses n"aher untersucht die sp"ater oft bei der Simulation sichtbar sein sollen. Zun"achst wird dabei die Normalisierung eingef"uhrt die es auch einfacher macht Aussagen "uber das erwartete Verhalten des Prozesses bzw. der Population zu machen. 

\subsection{Normalisierung des BPDL Prozesses}
	Wie schon zuvor erwähnt ist es für uns wichtig die Tode und Geburten nicht auf der Ebene des Individuums, sondern der gesamten Population zu betrachten. Dazu wird die LPA(Large Population Approximation) Normalisierung aus \cite{fournier2004microscopic} eingeführt.\\
	Hierfür wird der Prozess mit einem Parameter K skaliert und es ergibt sich eine neue Zufallsvariable:
	\[ \nu_t^K := \frac{1}{K} \nu_t \]
	Um f"ur $ \nu_t^K $ das selbe Verhalten wie f"ur $ \nu_t $ zu erhalten, m"ussen einige Anpassungen vorgenommen werden.\\
	Zun"achst wird die Anfangsgröße $ n_0^K $ der Population proportional zu K gewählt.
	Die Raten für Geburten und natürliche Tode der Individuen bleiben unverändert. Da die Populationsgröße jedoch quadratisch in Wettbewerbsrate einfließt, sollte $ c^K = \frac{c}{K} $ gelten, da sonst die K-fach erh"ohte Population mit einem intensives Aussterben den Vergleich verf"alschen w"urde. \\
	Ein Beispiel f"ur eine LPA-Normalisierung sieht folgendermaßen aus:
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{./Pictures/LPANormalisierungK100}
		\caption[LPAK100]{LPA Normalisierung mit K=100}
		\label{LPA Normalisierung K=100}
	\end{figure}
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{./Pictures/LPANormalisierungK10000}
		\caption[LPAK100]{LPA Normalisierung mit K=10000}
		\label{LPA Normalisierung K=10000}
	\end{figure}
	Ein weiteres Beispiel dazu ist Abbildung (\ref{Konvergenz_K=100000}).\\
	\textit{Für eine Anfangspoulation die aus zwei Merkmalen bestehet, konvergiert der Prozess ohne Mutation gegen die Lösung der Konkurrenz Lotka-Volterra Gleichung für zwei Spezies (Siehe Kapitel 11 -Law of Large Numbers- von Ethien und Kurtz \cite{ethier2009markov}).}
	
	\subsection{Monomorphes Gleichgewicht}
	Wir stellen fest dass im Falle der monomorphen Population f"ur $ K \to \infty $, $ \nu_t $ gegen eine Funktion konvergiert die folgende Gleichung erf"ullt:
	\begin{align}
	\begin{split}
		\dot{n} &= (b(x) - d(x) - n \cdot c(x,x)) \cdot n \\
		n(0) &= n_0
	\end{split}
	\end{align}
	Wir wollen hieraus eine einen stabilen Zustand f"ur die Population ermitteln indem sich die Populationsgr"o"se nicht mehr "andern darf:
	\begin{align}
	\begin{split}
		0 &= \dot{n} = (b(x) - d(x) - nc(x,x))n\\
		\Rightarrow 0 &= b(x) - d(x) - nc(x,x)\\
		\Rightarrow \bar{n} &= \frac{b(x) - d(x)}{c(x,x)}
	\end{split}
	\end{align}
	$ \bar{n} $ ist somit das Gleichgewicht einer monomorphen Population. Zudem gilt dass stets eine Konvergenz der Population gegen $ \bar{n} $ f"ur beliebige Startwerte vorliegt.
	
%	Mit wachsendem K konvergiert das System gegen eine deterministische Funktion wie ich hieran noch erkl"aren muss \cite{ethier2009markov}.
	
	\subsection{Der TSS Grenzwertprozess}
	\textit{Die bei der LPA-Normalisierung erw"ahnte Konvergenz  gilt auch f"ur d Merkmale mit Mutation mit dem selben Argument, da die Mutationen nach rechts und links begrenzt sind. Dadurch hat man immer nur maximal d Subpopulationen.\\
	Die Differenzialgleichung zu diesem Prozess konvergiert d-dimensional und "ahnelt bis auf den Mutationsanteil der d-dimensionalen Konkurrenz Lotka-Volterra Gleichung.}\\
	Genau wie bei der LPA-Normalisierung ergeben sich TSS-Prozesse(Trait Substitution Sequence) als Grenzprozesse von BPDL-Prozessen. Zu der LPA-Normalisierung sollten jedoch mit größer werdendem K die Mutationen seltener werden 
	\[ \left( \frac{1}{e^{VK}} << \mu_K << \frac{1}{K log(K)} \right), \] 
	also die Mutationswahrscheinlichkeit gegen 0 streben.\\ 
%	Warum $ \mu_K $ so gew"ahlt wird, ist n"aher im Kapitel "{}TSS Prozesse"{} erkl"art.\\ 
	\textbf{Frage:} Warum soll $ \mu_K $ in dem obigen Bereich gew"ahlt werden?\\
	\textbf{Antwort:} Dank Freidlin and Wenzell \cite{freidlin2012random} erwarten wir dass unsere dominante Spezies $ exp(cK) $ Zeiteinheiten im Gleichgewicht bleibt. Schlie"slich k"onnen wir so kontrollieren wie lange uns eine dominante Spezies die f"ur eine mutative Geburt in Frage kommt erhalten bleibt. Und dadurch dass die Mutationen exponentiell verteilt sind ben"otigt man ein eine Rate $ \mu_K >> \frac{1}{e^{cK}} $ um eine Zeit von $ exp(cK) $ nicht zu "uberschreiten, was die erste Schranke rechtfertigt.\\
	Um die zweite Schranke zu Rechtfertigen betrachten wir nun die Zeit die ein Mutant braucht um ein dominantes Merkmal aussterben zu lassen. Das wird uns die M"oglichkeit geben einer neuen Mutation so viel Zeit zu lassen bis das derzeit benachteiligte Merkmal ausgestorben ist.\\
	Angenommen es ereignet sich eine Mutation und der Mutant $ x $ ist fitter ($ f(x,y) > 0 $), so wird es mit positiver Wahrscheinlichkeit eine Invasion ausl"osen. Wenn man Branching Prozesse mit dem Lotka-Volterra System vergleicht, kommt man darauf dass die ben"otigte Zeit zum Verdr"angen und Aussterben des urspr"unglich dominanten Merkmals von der Ordnung $ \log(K) $ ist.
	Diese Invasion wird eine Zeit von der Ordnung $ \log(K) $ ben"otigen. Das l"asst sich folgern indem man Branching Prozesse mit 
	
	Skaliert man nun noch zusätzlich die Zeit, so führt dies dazu, dass der Prozess ausreichend Zeit zwischen zwei Mutationen hat um ein benachteiligtes Merkmal zu verdr"angen.
%	die Zeit, die ein Merkmal benötigt, um sich gegenüber einem anderen durchzusetzen und dieses zu verdrängen, infinitesimal klein wird. 
	Somit erlaubt uns die LPA-Annahme von einer deterministischen Populationsdynamik zwischen zwei Mutationen auszugehen \cite{raey}.\\
%	Somit simulieren die TSS-Prozesse eine Population, die zu jedem Zeitpunkt monomorph ist und sich im entsprechenden Gleichgewicht befindet.
	\begin{figure}[H]
		\centering
		\includegraphics[width=1 \linewidth]{../BachelorArbeit/Pictures/TSS2_pure_small}
		\caption[TSS Prozess wechselnder Dominanz]{TSS Prozess mit: K = 1000 und $ 4 \cdot 10^6 $ Spr"ungen}
		\label{fig:TSS2_pure_small}
	\end{figure}
	
	\subsection{Die Fitnessfunktion}
	Spätestens jetzt wird die Fitnessfunktion interessant:
	\[ f(x,y) = b(x) - d(x) - c(x,y)\bar{n}_y \]
	Die Fitness-Funktion gibt an wie gut sich ein Mutant eines ausgestorbenen Merkmals in einem Gleichgewichtssystem durchsetzten kann. \\
	Man erkennt dass die Fitnessfunktion die Geburtenrate eines Mutanten $ b(x) $ dem zu erwarteten Widerstand, in Form der Todesrate $ - d(x) - c(x,y)\bar{n}_y $, gegen"uberstellt. Hierbei wird $ c(x,x) $ nicht ber"ucksichtigt weil es im Grenzwert mit K immer geringeren Einfluss hat, und gleicherma"sen haben wenige $ x  $ kaum Einfluss auf den Gleichgewichtszustand $ \bar{n}_y $ von $ y $. Damit begr"undet sich der Widerstand gegen den Mutanten durch die eigene Todesrate und die Konkurrenz der nahezu konstanten $ c(x,y)\bar{n}_y $. \\
	Die Fitness-Funktion ist also die asymptotische Wachstumsrate von x, wenn y sich in einem Gleichgewichtszustand befindet und nur wenige Individuen von Typ x in der Population vorhanden sind.\\
	Man kann in dieser Stelle bereits erahnen dass die Fitnessfunktion bzw. die Wachstumsrate eines Mutanten die M"oglichkeit bietet aussagen "uber die Invasionswahrscheinlichkeit bietet. Und tats"achlich wird in \cite{Champagnat20061127} eine Konvergenz f"ur $ K \to \infty $ von einer Konvergenz gegen 
	\[ \frac{\left[ f(y,x)\right]_+ }{b(y)} \]
	gesprochen. Begr"undet wird das durch [...]\\
	
	\subsection{Gleichgewicht im dimorphen Fall}
	Wir wissen mittlerweile dass die Population für $ K \to \infty $ gegen eine deterministische Funktion konvergiert. Angenommen es gibt wieder keine Mutation, dann gilt:\\
	\begin{align}
	\begin{split}
		\dot{n}_x & = n_x (b(x) - d(x) - c(x,x)n_x - c(x,y) n_y) \quad n_x(0) = n_{x,0} \\
		\dot{n}_y & = n_y (b(x) - d(x) - c(x,x)n_x - c(x,y) n_y) \quad n_x(0) = n_{x,0}
	\end{split}
	\end{align}
	Hier sieht man bereits leicht dass $ (\bar{n}_x, 0) $, $ (0, \bar{n}_y) $ und $ (0,0) $ stabile Zust"ande sind. Jedoch gibt es in diesem Fall auch einen Zustand indem eine Koexistenz beider Merkmale herrschen kann:
	\begin{align}
	\begin{split}
		n_x &= \frac{(b(x) - d(x))c(y,y)-(b(y)-d(y))c(x,y)}{c(y,y)c(x,x) - c(y,x)c(x,y)}\\
		n_y &= \frac{(b(y) - d(y))c(x,x)-(b(x)-d(x))c(y,x)}{c(y,y)c(x,x) - c(y,x)c(x,y)}
	\end{split}
	\end{align}
	Die BPDL Simulationen erkennen dimorphe und monomorphe Populationen und stellen stets einen passenden stabilen Zustand $ n_x $, bzw. $ \bar{n}_x $ dar. \\
	Um im dimorphen Fall zu entscheiden unter welchen Voraussetzungen zu welchem Gleichgewicht konvergiert wird, ben"otigen wir \cite[Proposition 3]{Champagnat20061127}. Darin werden die Gleichgewichte $ (\bar{n}_x, 0) $ und $ (0, \bar{n}_y) $ untersucht:
	\begin{itemize}
		\item[] Falls $ f(y,x) < 0 $, so ist $ (\bar{n}_x, 0) $ ist ein stabiler Zustand.
		\item[] Falls jedoch $ f(y,x) > 0 $ und $ f(x,y) < 0 $, so ist $ (0, \bar{n}_y) $ stabil und $ (\bar{n}_x, 0) $ ist instabil. In diesem Fall
	\end{itemize}
	Die Idee des Beweises ist [...]\\
	
	Das folgende Bild zeigt sowohl die Konvergenz gegen das eben berechnete Gleichgewicht, als auch das deterministische Verhalten f"ur sehr gro"se K:
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\linewidth]{./Pictures/BigKInstance_Equillibrium}
		\caption[Konvergenz_K=100000]{Konvergenz mit K=100000 und $ 15\cdot10^6 $ Spr"ungen}
		\label{Konvergenz_K=100000}
	\end{figure}

\clearpage
\section{Simulation}
In diesem Kapitel wird der Kern der Simulation algorithmisch n"aher untersucht. Dieser Kern besteht im Wesentlich aus einem Sprung des BPDL Prozesses.
Dabei wird zwischen der Implementierung und dem Pseudocode unterschieden, weil bei der Implementierung sorgf"altig auf die Trennung der Aufgabenbereiche geachtet wurde, welche sp"ater beim Verhaltenstest sehr wichtig werden und im 5. Kapitel weiter verwendet werden.\\
Die hier verwendete Vorgehensweise unterscheidet sich von der aus \cite{fournier2004microscopic} weil...
	\subsection{Implementierung}
	Die Simulation durchl"auft mehrere Schritte bis ein vollst"andiger Sprungs von $ \nu_t $ abgeschlossen ist. Hier wird beschrieben in welcher Reihenfolge welche Schritte durchlaufen werden und welche Aufgabe diese erf"ullen.\\
	Am Ende werden alle Funktionsaufrufe (Schritte) und Zusammenh"ange in Abbildung (\ref{fig:PseudoCodeForBThesis}) als ein Ablauf-Tiefen Diagramm illustriert.\\
	Im Code wird dabei objektorientiert mit Klassen und Objekten gearbeitet. Da diese Details nicht besonders von Interesse sind wird eher ein heuristischer "Uberblick der Implementation gegeben. So kann hier z.B. angenommen werden dass man mit der Variable "{}Members[i]"{} Zugriff auf die Anzahl der Individuen des i-ten Merkmals hat, was im jedoch Code komplexer realisiert werden musste.\\
	
	\subsubsection{Raten berechnen}	
	Zun"achst m"ussen wir die Raten wissen nach der die exponentiellen Uhren gestellt werden bevor ein Merkmal und Ereignis ausgew"ahlt werden kann.\\
	Die Todesrate setzt sich aus der intrinsischen Todesrate und der durch Wettbewerb zusammen und ist zu Beginn 0.\\
	
	Die folgende Funktion addiert die intrinsische Todesrate zur aktuellen Todesrate. Dabei wird direkt das Superpositionsprinzip genutzt um die gesamte intrinsische Todesrate des Merkmals in "{}TotalDeathRate[i]"{} aufzuaddieren.
	\begin{algorithm}[H]
		\caption{addTotalIntrinsicDeathRateOf(TraitIndex: i)}
		\begin{algorithmic}[1]
			\ENSURE{addiert zur Todesrate die intrinsische-Todesrate}
			\STATE TotalDeathRate[i] = DeathRate[i] $ \cdot $ Members[i]
		\end{algorithmic}
	\end{algorithm}
	Diese Funktion addiert die Wettbewerbs-Todesrate zur aktuellen Todesrate.
	\begin{algorithm}[H]
		\caption{addTotalCompDeathRateOf(TraitIndex: i)}
		\begin{algorithmic}[1]
			\ENSURE{addiert zur Todesrate die Wettbewerbs-Todesrate}
			\FOR{j=0 \TO n-1}
				\STATE TotalDeathRate[i] += CompDeathRate[i,j] $ \cdot $ Members[i] $ \cdot $ Members[j];
			\ENDFOR
		\end{algorithmic}
	\end{algorithm}
	Auch wenn es vielleicht so erscheint dass man zu stark trennt, so ist doch f"ur das verwendete Programmierkonzept entscheidend dass jede Funktion nach M"oglichkeit eine genau Aufgabe hat, weshalb diese beiden Funktionen getrennt wurden. Wie man vermuten kann werden diese von einer Funktion aufgerufen die f"ur das Berechnen der gesamten Todesrate zust"andig ist.
	\begin{algorithm}[H]
		\caption{calculateTotalDeathRates()}
		\begin{algorithmic}[1]
			\ENSURE{berechnet die gesamten Todesraten aller Merkmale}
			\FOR{i=0 \TO n-1}
				\STATE TotalDeathRate[i] = 0;
				\STATE addTotalIntrinsicDeathRateOf(i);
				\STATE addTotalCompDeathRateOf(i);
			\ENDFOR
		\end{algorithmic}
	\end{algorithm}
	
	Schlie"slich kommen wir zur Berechnung der Geburtsrate pro Merkmal. Auch hier sollen Mutationen und intrinsische Geburten gesondert berechnet werden. Zusammengefasst:
	\begin{algorithm}[H]
		\caption{calculateTotalBirthRates()}
		\begin{algorithmic}[1]
			\ENSURE{berechnet die gesamten Geburtsraten aller Merkmale}
			\STATE $ \qquad $ $ \downarrow $ \textbf{intrinsische Geburtenrate} $ \downarrow $
			\FOR{i=0 \TO n-1}
				\STATE TotalBirthRate[i] = Members[i] $ \cdot $ BirthRate[i] $ \cdot $ (1 - Mutation);
			\ENDFOR
			\STATE $ \qquad $ $ \downarrow $ \textbf{Mutationsraten} $ \downarrow $
			\FOR{i=1 \TO n-2}
				\STATE TotalBirthRate[i] += Members[i-1] $ \cdot $ BirthRate[i-1] $ \cdot $ Mutation $ \cdot $ 0.5;
				\STATE TotalBirthRate[i] += Members[i+1] $ \cdot $ BirthRate[i+1] $ \cdot $ Mutation $ \cdot $ 0.5;
			\ENDFOR
			\STATE TotalBirthRate[0] += Members[1] $ \cdot $ BirthRate[1] $ \cdot $ Mutation $ \cdot $ 0.5;
			\STATE TotalBirthRate[n-1] += Members[n-2] $ \cdot $ BirthRate[n-2] $ \cdot $ Mutation $ \cdot $ 0.5;
		\end{algorithmic}
	\end{algorithm}
	 Jetzt sind wir bereit eine Funktion aufzurufen die aus den vorher berechneten Geburts und Todesraten pro Merkmal durch Superposition eine totale Eventrate berechnet, nach der wir eine exponentielle Uhr stellen k"onnen die schlie"slich das klingeln der ersten aller Merkmalsuhren simuliert.
	 \begin{algorithm}[H]
 		\caption{calculateTotalEventRate()}
 		\begin{algorithmic}[1]
 			\ENSURE{berechnet die Total Eventrate}
 			\STATE TotalEventRate = 0;
 			\FOR{i=0 \TO n-1}
 				\STATE TotalTraitRate[i] = TotalBirthRate[i] + TotalDeathRate[i];
 				\STATE TotalEventRate += TotalTraitRate[i];
 			\ENDFOR
 		\end{algorithmic}
 	\end{algorithm}
 	Hier f"allt auf dass wir auch die "{}TotalTraitRate"{} oder Totale Merkmalsrate gespeichert haben. Diese repr"asentiert die gesamte Ereignisrate eines Merkmals.\\
 	Zum Schluss sollte es eine Funktion geben, die alle bisherigen Funktionen in der richtigen Reihenfolge ausf"uhrt und so die Berechnung aller Ereignisraten sichert:
 	\begin{algorithm}[H]
 		\caption{calculateEventRates()}
 		\begin{algorithmic}[1]
 			\ENSURE{stellt sicher dass alle akutellen Raten berechnet wurden}
 			\STATE calculateTotalDeathRates();
 			\STATE calculateTotalBirthRates();
 			\STATE calculateTotalEventRate();
 		\end{algorithmic}
 	\end{algorithm}
	
	\subsubsection{Ereignis und Zeit bestimmen}
	
	Mit den zuvor berechneten Raten ist es jetzt einfach die Dauer bis zum n"achsten Ereignis zu bestimmen. An dieser Stelle verwende ich eine Funktion zum Ziehen einer exponentiell verteilten Zufallsvariable "{}rollExpDist(Parameter)"{} die nicht weiter interessant ist und deshalb nicht erl"autert wird.
 	\begin{algorithm}[H]
 		\caption{sampleEventTime()}
 		\begin{algorithmic}[1]
 			\ENSURE{Zieht die n"achste Ereigniszeit}
 			\STATE EventTime = rollExpDist(TotalEventRate);
 			\STATE Timeline += EventTime;
 		\end{algorithmic}
 	\end{algorithm}
 	Jetzt bleibt zu bestimmen wem was passiert. Also welches Ereignis welches Merkmal treffen wird. Daf"ur wenden wir das Superpositionsprinzip in anderer Richtung an als bisher:\\
 	Zum bestimmen des auserw"ahlten Merkmals beachten wir den Anteil der Merkmale an der Totalen Eventrate. Dieser ist klar erkennbar durch die Summe:
 	\[ \text{TotalTraitRate} = \sum_{i = 0}^{n - 1} \text{TotalTraitRate[i]} \]
 	Also hat das $ i-te $ Merkmal mit Wahrscheinlichkeit $ \frac{TotalTraitRate[i]}{TotalEventRate} $ das Ereignis ausgel"ost. Um also das verantwortliche Merkmal auszuw"ahlen, k"onnen wir eine Uniform verteilte Zufallsvariable ziehen und entscheiden welche der $ i $ Merkmalsraten damit gemeint ist. Abbildung (\ref{SelectTrait}) illustriert den Auswahlprozess.
 	\begin{figure}[H]
		\centering
		\includegraphics[width=1\linewidth]{./Pictures/SelectTrait}
		\caption[]{Auswahl des Merkmals nach Anteil an der TotalEventRate}
		\label{SelectTrait}
	\end{figure}
	Im Code wird daf"ur iterativ gepr"uft ob "{}X $ \sim $ Unif(TotalEventRate)"{} im ersten Intervall der L"ange TotalTraitRate[0] liegt. 
	\begin{itemize}
		\item[] Falls ja, so wird dieses Merkmal gew"ahlt und die Funktion wird verlassen.
		\item[] Falls nicht so wird das Merkmal $ 0 $ aus den relevanten Merkmalen entfernt und X wird um die Intervallänge TotalTraitRate[0] reduziert um schlie"slich erneut mit dem ersten relevanten Intervall verglichen zu werden (jetzt TotalTraitRate[1]). Auf diese weise n"ahert man sich immer weiter dem getroffenen Merkmal:
	\end{itemize}
	\begin{algorithm}[H]
 		\caption{choseTraitToChange()}
 		\begin{algorithmic}[1]
 			\ENSURE{w"ahlt ein Merkmal zum "Andern aus}
 			\STATE X = rollUnifDist(TotalEventRate);
 			\FOR{i=0 \TO n-1}
 				\IF{X $ \le $ TotalTraitRate[i]}
 					\STATE ChosenTrait = i;
 					\STATE return;
 				\ENDIF
 				\STATE X -= TotalTraitRate[i];
 			\ENDFOR
 		\end{algorithmic}
 	\end{algorithm}
 	Auf die selbe Weise wird entschieden welches Ereignis eintrifft und speichern diese Entscheidung in "{}isBirth"{}. Da wir hier jedoch nur Geburt und Tod zur Auswahl haben w"urde sich nat"urlich eine Bernoulli verteilte Zufallsvariable ergeben mit, 
 	\[ \text{isBirth} \sim \text{Bern(TotalBirthRate[ChosenTrait])} \]
 	Im Code wurde "{}isBirth"{} folgenderma"sen gezogen:
	\begin{algorithm}[H]
 		\caption{choseEventType()}
 		\begin{algorithmic}[1]
 			\ENSURE{w"ahlt ein Ereignis f"ur das entsprechende Merkmal aus}
 			\STATE X = rollUnifDist(TotalTraitRate[ChosenTrait]);
 			\IF{X $ \le $ TotalBirthRate[ChosenTrait]}
 				\STATE isBirth = true;
 			\ELSE
 				\STATE isBirth = false;
 			\ENDIF
 		\end{algorithmic}
 	\end{algorithm}
 	Danach muss noch das Ereignis aus Alg. 9 auf das Merkmal aus Alg. 8 angewendet werden.
	\begin{algorithm}[H]
 		\caption{executeEventTypeOnTrait()}
 		\begin{algorithmic}[1]
 			\ENSURE{wendet das gew"ahlte Ereignis auf das gew"ahlte Merkmal an}
 			\STATE X = rollUnifDist(TotalTraitRate[ChosenTrait]);
 			\IF{isBirth}
 				\STATE Members[ChosenTrait] += 1;
 			\ENDIF
 			\IF{$ \neg \text{isBirth} $ \& Members[ChosenTrait] $ > $ 0}
 				\STATE Members[ChosenTrait] -= 1;
 			\ENDIF
 		\end{algorithmic}
 	\end{algorithm} 	
 	Zum Schluss wir noch eine Funktion erstellt welches das Ausf"uhren eines Ereignisses in richtiger Reihenfolge ausf"uhrt und in einem Schritt aus gegebenen Raten die eine Ver"anderung der Population durchf"uhrt.
 	\begin{algorithm}[H]
 		\caption{changeATrait()}
 		\begin{algorithmic}[1]
 			\ENSURE{l"asst ein Ereignis ein Merkmal treffen}
 			\STATE choseTraitToChange();
 			\STATE choseEventType();
 			\STATE executeEventTypeOnTrait();
 		\end{algorithmic}
 	\end{algorithm} 
	Aus diesen 3 wesentlichen Schritten
	\begin{itemize}
		\item Raten berechnen
		\item Ereigniszeit ziehen
		\item Ereignis eintreten lassen
	\end{itemize}
	kann schlie"slich eine sehr "ubersichtliche Funktion konstruiert werden die einen kompletten Sprung des Prozesses durchf"uhrt.
	\begin{algorithm}[H]
 		\caption{makeEvolutionStep()}
 		\begin{algorithmic}[1]
 			\ENSURE{l"asst ein Ereignis ein Merkmal treffen}
 			\STATE calculateEventRates();
 			\STATE sampleEventTime();
 			\STATE changeATrait();
 		\end{algorithmic}
 	\end{algorithm}
	 	
	\subsubsection{"Ubersicht}
	Hier ist eine "Ubersicht aller Funktionen, ihrer Reihenfolge und Aufruftiefe. \\
	Die Funktionen wurden auf englisch beschrieben, weil sie damit eine Referenz zu der im Quellcode beschriebenen Funktion darstellen. Z.B. "{}make one evolution step"{} verweist auf die Funktion "{}makeEvoultionStep"{}, oder "{}calculate event rates"{} $ \to $ "{}calculateEventRates"{} etc.
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\linewidth]{../UMLs/PseudoCodeForBThesis}
		\caption{Diagramm mit Funktionsaufrufen und ihren Tiefenebenen}
		\label{fig:PseudoCodeForBThesis}
	\end{figure}
	Normalisierung [...]
	
	\subsection{Pseudocode}
	Nat"urlich l"asst sich der Ablauf eines Sprunges auch durch Pseudocode in eine Funktion zusammenfassen:
	
	\begin{algorithm}[H]
		\caption{EvolutionStep()}
		\begin{algorithmic}[1]
			\ENSURE{A full evolution Step happened}
			\REQUIRE $ t, X = \{0,\dots, n-1\} $
			\STATE $ \qquad \downarrow $ \textcolor[rgb]{0,0,0.55}{calculateEventRates}() $ \downarrow $
			\FOR{ $ x \in X $ }
				\STATE $  D(x) := n_t(x) \cdot \left( d(x) + \sum_{y \in X} c(x,y) \cdot n_t(y) \right) $
				\STATE $ B(x) := \underbrace{b(x) \cdot (1 - \mu) \cdot n_t(x)}_{arteigene}  $
				\IF{$ x > 0 $}
					\STATE $ B(x) += \underbrace{b(x-1)\cdot n_t(x-1)}_{Mutation Links} \cdot \frac{\mu}{2} $
				\ENDIF
				\IF{$ x < n-1 $}
					\STATE $ B(x) += \underbrace{b(x+1)\cdot n_t(x+1)}_{Mutation Rechts} \cdot \frac{\mu}{2} $
				\ENDIF
				\STATE $ TotalTraitRate(x) = B(x) + D(x) $
			\ENDFOR
			\STATE $ TotalEventRate := \sum_{x \in X} TotalTraitRate(x) $
			\STATE $ \qquad \downarrow $ \textcolor[rgb]{0,0,0.55}{sampleEventTime}() $ \downarrow $
			\STATE sample $ Z \sim exp(TotalEventRate) $
			\STATE $ t += Z $
			
			\STATE $ \qquad \downarrow $ \textcolor[rgb]{0,0,0.55}{choseTraitToChange}() $ \downarrow $
			\STATE sample $ Y \sim U(0,TotalEventRate) $
			\FOR{$ x \in X $}
				\IF{$ Y \le TotalTraitRate(x) $}
					\STATE $ ChosenTrait := x $
					\STATE break
				\ENDIF
				\STATE $ Y -= TotalTraitRate(x) $
			\ENDFOR
			
			\STATE $ \qquad \downarrow $ \textcolor[rgb]{0,0,0.55}{choseEventType()} $ \downarrow $
			\STATE sample $ Y \sim U(0,TotalTraitRate(ChosenTrait)) $
			\IF{$ Y \le B(ChosenTrait) $}
				\STATE isBirht := true
			\ELSE
				\STATE isBirth := false
			\ENDIF
			
			\STATE $ \qquad \downarrow $ \textcolor[rgb]{0,0,0.55}{executeEventTypeOnTrait()} $ \downarrow $
			\IF{isBirth}
				\STATE $ n_t(ChosenTrait) += 1 $
			\ELSE
				\IF{$ n_t(ChosenTrait) \ge 0 $}
					\STATE $ n_t(ChosenTrait) -= 1 $
				\ENDIF
			\ENDIF
		\end{algorithmic}
	\end{algorithm}
	
	\subsection{Optimierung f"ur viele Merkmale}
	F"ur eine Simulation ist klar dass in Abh"angigkeit der Spr"unge (wenn auch hoher) linearer Aufwand zu erwarten ist.\\
	Zwar ist der nachvollziehbar am Modell gehalten worden, jedoch ist durch die Wettbewerbsrate ein quadratischer Aufwand in der Anzahl der Merkmale nicht vermieden worden.\\
	In unserer Situation werden wir immer eine "uberschaubare Menge an Merkmalen haben, aber der Nutzten meiner Optimierung ist bereits ab einem Merkmal sp"urbar sein (praktisch wurde er erst ab 2 gemessen).\\
	Nach meinen Tests, die ich sp"ater im Kapitel "{}Verhaltenstest"{} einf"uhre, ergab sich der gr"o"ste zeitliche Aufwand in der Berechnung der Raten (genauer der Todesraten), was auch zu erwarten war.\\
	Diese Optimierung vermeidet es die Raten komplett neu zu berechnen und m"ochte sie stattdessen anpassen. \\
	Dazu werden die Raten nicht zu Beginn berechnet wie zuvor in Algorithmus 12 "{}makeEvolutionStep()"{} in der 1. Zeile. Als erstes wird mit den aktuellen Raten eine Ereigniszeit gezogen "{}sampleEventTime()"{} und anschlie"send ein Ereignis ausgel"ost "{}changeATrait()"{}, welches es erm"oglicht die n"achsten Raten anzupassen "{}adjustNewEventRates"{}.\\
	Daf"ur wird zun"achst unterschieden ob ein Tod oder eine Geburt eingetreten ist. Das l"asst sich leicht mit der in Algorithmus 9 erw"ahnten "{}isBirth"{} Variable entscheiden.\\
	Angenommen es ereignet sich eine Geburt. Damit kann zusammen mit dem ausgew"ahlten Merkmal "{}chosenTrait"{} folgende Anpassungen gemacht werden:
	\begin{itemize}
		\item Die \textbf{intrinsische Todesrate} von "{}chosenTrait"{} wird um die das geborene Individuum erh"oht:\\ 
		TotalDeathRate[chosenTrait] += DeathRate[chosenTrait];
		\item Die \textbf{Todesrate durch Wettbewerb} wird bei jedem Merkmal um das geborene Individuum erh"oht:\\
		TotalDeathRate[i] += CompDeathRate[i][chosenTrait]; $ \qquad \forall \text{ i} \in X $
		\item Die \textbf{Geburtsraten} werden genauso wie die Todesraten behandelt:\\
		TotalBirthRate[chosenTrait] += BirthRate[chosenTrait];
		\item Und passend die Mutationsraten:\\
		TotalBirthRate[i] += Mutation $ \cdot $ 0.5 $ \cdot $ BirthRate[chosenTrait]; \\
		$\forall \text{ i } \sim \text{ chosenTrait} $
		\item Zum Schluss noch die Totale Ereignisrate:\\
		Hier kommt man nicht herum alle Totalen Raten erneut auszurechnen.
	\end{itemize}
	Man erkennt dass hier keine quadratische Abh"angigkeit der Merkmale mehr zu finden ist.
	
	
\clearpage	
	\noindent\rule{\textwidth}{2pt}
	\begin{center}
		$ <<< \quad \downarrow $ In Arbeit $ \downarrow \quad >>> $
	\end{center}

\section{Das Programm}
Nun kommen wir zur eigentlichen Simulation. Damit ist sowohl die Darstellung als auch die Programmarchitektur gemeint. 
	\subsection{Aufgabenteilung und Flexibilität}
	Die Idee der getrennten Aufgabenbereiche geht darauf zurück dass eine möglichst große Unabhängigkeit zwischen Arbeitsschritten notwendig ist um das Programm flexibel zu halten und sogenannten "{}Coderot"{} - "{}faulen Code"{} zu verhindern. Das bedeutet dass das Programm mit steigender Komplexität zunehmend unflexibler wird, also das Hinzufügen weiterer Features oder das Ändern/Verbessern zu sogenanntem "{}undefiniertem Verhalten"{} führt. (kurze Erklärung zum Begriff).\\
	Die Architektur des Programms kann grob in drei Module gefasst werden. 
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{./Pictures/Bild_Module}
		\caption[Module]{Arbeitsmodule und Klassenabhängigkeiten}
		\label{Module und Klassen}
	\end{figure}
	Innerhalb der Arbeitsschritte sollte dabei genau die selbe Regel der Unabhängigkeit gelten wie bei den Modulen.
	
	\subsection{Layout}
	\begin{itemize}
		\item Die Bedienung des Programms sollte das lesen und Anzeigen der Merkmals-Parameter bereitstellen. Da es viele Parameter gibt und die Anzahl der Parameter quadratisch mit der Anzahl der betrachteten Merkmale steigt, bietet sich das Lesen aus zuvor beschriebenen Dateien an.
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.7\linewidth]{./Pictures/MainWindow_Start}
			\caption[Startwindow]{MainWindow nach dem Start}
			\label{MainWindow_Start}
		\end{figure}

		Zur Darstellung der gelesenen Parameter habe ich ein Baumstruktur gewählt.
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.7\linewidth]{./Pictures/MainWindow_ParameterBaum}
			\caption[MainWindow_Parameter]{MainWindow mit geladenen Parametern}
			\label{Baumstruktur}
		\end{figure}
		\item Die letzte Herausforderung bestand darin eine Instanz durch das Programm geleitet erstellen zu können. Während diese Aufgabe bei einer Konsolenanwendung (bekannt aus den klassischen c Programmen) denkbar einfach mit "{}printf"{} und "{}scanf"{} erledigt werden konnte, sollte bei einem GUI eine Lösung her die Inputkonflikte verhindert und das Einlesen der Daten denkbar einfach macht. Dafür war es sinnvoll "{}Enter"{} als Bestätigung abzufangen und sicherzustellen dass der Curser nur innerhalb des gewünschten Feldes bleibt.
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.7\linewidth]{./Pictures/MainWindow_createFile}
			\caption[erstelle Datei]{Nach Klick auf "{}create File"{} werden die neuen Parameter einzeln abgefragt}
			\label{fig:MainWindow_createFile}
		\end{figure}
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.7\linewidth]{./Pictures/MainWindow_FileCreated}
			\caption[Datei erstellt]{Nach Eingabe des letzten Parameters}
			\label{fig:MainWindow_FileCreated}
		\end{figure}
	\end{itemize}
	Was die Darstellung der Graphen angeht, hat sich ein einfaches Bild des fertigen Plots durchgesetzt, wobei das Zoomen und ziehen des Bildes notwendige Elemente zur Untersuchung des Graphen sind. Zusätzlich ist es notwendig viele Bilder vergleichen zu können. Hierfür wurde das Abspeichern des Bildes gewünscht.\\
	Die Simulation wird gestartet nachdem man auf den "{}Plot"{} Button drückt. Dabei wird ein neues Fenster geöffnet.
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{./Pictures/PlotWindow_start}
		\caption[PlotWindow_start]{Start des PlotWindow}
		\label{PlotWindow_start}
	\end{figure}
	Sobald der Plot Button gedrückt wurde und das Fenster angezeigt wird, arbeitet die Simulation bereits im Hintergrund in einem eigenen Thread. Dort werden alle notwendigen Iterationen bzw. Sprünge der Population durchgeführt ohne den Hauptthread damit zu belasten.\\ Während dieser Arbeiterthread aktiv arbeitet wird der "{}Plot"{} Button ausgegraut um mehrfaches Auslösen zu vermeiden und um anzuzeigen dass die Rechnung im Gange ist.\\
	Der Arbeiterthread gewährleistet nicht nur eine flüssige Interaktion mit dem Programm, sondern verhindert auch effektiv dass das Betriebssystem denkt das Programm wäre Abgestürzt oder würde nicht mehr ordnungsgemäß funktionieren. Das würde sonst folgendes evtl. bekannte Bild hervorrufen:
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{./Pictures/KeineRueckmeldung}
		\caption[Keine Rueckmeldung]{Hauptthread wurde überlastet}
		\label{Keine Rueckmeldung}
	\end{figure}
	Wenn die Simulation  einen gewünschten Zustand erreicht hat, oder die maximale Anzahl an gewünschten Iterationen absolviert hat, werden anschließend maximal 10mio Punkte auf dem Koordinatensystem zu Graphen verbunden. Das kann so aussehen:
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{./Pictures/PlotWindow_smallBPDL}
		\caption[PlotWindow]{PlotWindow mit Dimorpher Population}
		\label{PlotWindow}
	\end{figure}

\clearpage
\section{Verhaltenstest - Korrektheit der Implementation}
(Korrektheit des Algorithmus nicht notwendig bzw möglich)
Ein ganz besonders interessantes Thema ist die Korrektheit der Implementation. Diese ist generell mit steigender Komplexität schwerer zu prüfen (besonders bei Zufallsbedingten Simulationen).\\
Daher habe ich das Prinzip der "{}Testgetriebene Entwicklung"{}  (Test Driven Develeopment) verwendet.\\
Dabei werden Funktionen des Programms unter vorher festgelegten Bedingungen laufen gelassen und mit einem erwarteten Verhalten verglichen. Das Ergebnis ist eine Ausgabe für Erfolg oder Misserfolg des Tests. Folgend ein Beispiel für eine Implementation eines einfachen Tests der prüft ob alle Parameter korrekt aus der Datei in die Objekte geschrieben werden.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{./Pictures/UnitTest}
	\caption[UnitTest]{UnitTest versichert korrektes lesen von Parametern aus Datei}
	\label{Unit Test}
\end{figure}
Anschließend ein Beispiel für einen Durchlauf der Testfunktionen:
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{./Pictures/TestResult_start}
	\caption[Test Resultat einer Test Datei]{Ergebnisse einiger Tests}
	\label{Test Results}
\end{figure}
Die Testfunktionen zeigen auch dass eine komplexe Verwendung der Simulationen über die graphische Darstellung hinaus einfach realisierbar ist.

	\subsection{Unit Tests der Algorithmusmodule}

\clearpage
\section{TSS Prozesse}
\noindent\rule{\textwidth}{2pt}
\begin{center}
	$ <<< \quad \downarrow $ Reserviert $ \downarrow \quad >>> $
\end{center}
\begin{center}
	\textbf{Frage:} Warum soll $ \mu_K $ in dem Bereich 
	\[ \left( \frac{1}{e^{VK}} << \mu_K << \frac{1}{K log(K)} \right), \] 
	gew"ahlt werden?\\
\end{center}

\textbf{Antwort:} Dank Freidlin and Wenzell \cite{freidlin2012random} erwarten wir dass unsere dominante Spezies $ exp(cK) $ Zeiteinheiten im Equilibrium bleibt. Schlie"slich k"onnen wir so kontrollieren wie lange uns eine dominante Spezies die f"ur eine mutative Geburt in Frage kommt erhalten bleibt. Und dadurch dass eine unsere Mutationen exponentiell verteilt sind ben"otigt man ein eine Rate $ \mu_K >> \frac{1}{e^{cK}} $ um eine Zeit von $ exp(cK) $ nicht zu "uberschreiten, was die erste Schranke rechtfertigt.\\
Um die zweite Schranke zu Rechtfertigen betrachten wir nun die Zeit die ein Mutant braucht um ein dominantes Merkmal aussterben zu lassen. Das wird uns die M"oglichkeit geben einer neuen Mutation so viel Zeit zu lassen bis das derzeit benachteiligte Merkmal ausgestorben ist.\\
Angenommen es ereignet sich eine Mutation und der Mutant $ x $ ist fitter ($ f(x,y) > 0 $), so wird es mit positiver Wahrscheinlichkeit eine Invasion ausl"osen. Wenn man Branching Prozesse mit dem Lotka-Volterra System vergleicht, kommt man darauf dass die ben"otigte Zeit zum Verdr"angen und Aussterben des urspr"unglich dominanten Merkmals von der Ordnung $ \log(K) $ ist.
Diese Invasion wird eine Zeit von der Ordnung $ \log(K) $ ben"otigen. Das l"asst sich folgern indem man Branching Prozesse mit 

\begin{center}
	$ <<< \quad \uparrow $ Reserviert $ \uparrow \quad >>> $
\end{center}
\noindent\rule{\textwidth}{2pt}

Bei TSS Prozessen beobachten wir wie sich Merkmale gegeneinander durchsetzten und sich verdrängen. (Tafelbild)\\
Genau wie bei der LPA-Normalisierung ergeben sich TSS-Prozesse(Trait Substitution Sequence) als Grenzprozesse von BPDL-Prozessen. Zu der LPA-Normalisierung sollten jedoch mit größer werdendem K die Mutationen seltener werden ($ \frac{1}{e^{VK}} << \mu_K << \frac{1}{K log(K)} $) , also die Mutationswahrscheinlichkeit gegen 0 streben. Skaliert man nun noch zusätzlich die Zeit, so führt dies dazu, dass die Zeit, die ein Merkmal benötigt, um sich gegenüber einem anderen durchzusetzen und dieses zu verdrängen, infinitesimal klein wird. Somit simulieren die TSS-Prozesse eine Population, die zu jedem Zeitpunkt monomorph ist und sich im entsprechenden (für $ K < \infty $ angepassten) Gleichgewicht befindet.\\
Spätestens jetzt wird die Fitness-Funktion interessant:
\[ f(x,y) = b(x) - d(x) - c(x,y)\bar{n}_y \]
Diese Fitness-Funktion gibt an, wie gut sich ein Merkmal gegenüber einem anderen durchsetzen kann. Sie ist die asymptotische Wachstumsrate von y, wenn x sich im Gleichgewichtszustand $ \bar{n}_x $ befindet und nur wenige Individuen von Typ y in der Population vorhanden sind. In der Simulation sieht man die Fitness der Merkmale zueinander in einer Matrix nach dem Laden der Parameter.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{./Pictures/MainWindow_BandMatrix}
	\caption[Fitness Matrix]{Fitness Bandmatrix}
	\label{MainWindow mit Fitness Bandmatrix}
\end{figure}
Mit der Fitness kann man eine Konvergenz der Wahrscheinlichkeit für das überleben einer Mutation vorhersagen:
\[ \frac{\left[ f(y,x)\right]_+ }{b(y)} \]
Da diese Wahrscheinlichkeit gerne bereits beim einlesen der Parameter angezeigt werden will, habe ich vor sie als farblich ansteigenden Akzent den Elementen der Zelle hinzuzufügen. Bisher wird in der Matrix etwas grün oder rot markiert. Rot falls eine Koexistenz vorliegt und grün wenn die Wahrscheinlichkeit für Dominanz des Mutanten über 50\% liegt.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{./Pictures/MainWindow_red_green_loaded}
	\caption[MainWindow_redGreenFitness]{Fitness Matrix mit roten und gruenen akzenten}
	\label{fig:MainWindow_red_green_loaded}
\end{figure}
Wenn der einfache BPDL Simulator für die Simulation dieses Prozesses verwendet werden würde, würde durch die seltenen Mutationen

	\subsection{Optimierung}
	Hier stelle ich die lineare Interpolation als eine Optimierung vor die "Ubersichtlichkeit, Analyse und Laufzeit deutlich verbessert. Dann beschreibe ich anhand von Bildern wie gut man Mutationen und deren Auswirkungen verfolgen kann und wie ich gepr"uft habe ob auch hier alles Korrekt l"auft.\\
	Schlie"slich erkl"are ich wie ich die Mutationszeitpunkte ermittelt habe.
	
	\subsection{Aufwand}
	H"angt nicht mehr nur von K ab...
	
	\subsection{Algorithmus}
\clearpage
\section{Ausblick}

\begin{itemize}
	\item Weiteres Abbruchkriterium = Zeit : sehr einfach zu implementieren.
\end{itemize}

\clearpage
\bibliography{science1}

\clearpage

\section{Fragen}
\begin{itemize}
	\item Normalisierung, Gleichgewicht und mono/dimorphe F"alle als einzelne Kapitel?
	\item Soll ich monomorphe BPDL Prozesse einf"uhren? Schlie"slich kann ich damit das fast sicheres Aussterben 
\end{itemize}

\section{Wozu hat es nicht mehr gereicht?}
Instanzbrowser oder Dateisuche.\\
einfaches Bearbeiten erstellter Instanzen.\\

\end{document}